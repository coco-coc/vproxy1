name: Auto Sync Fork with Releases

on:
  schedule:
    - cron: '0 17 * * *'  # 每天 UTC 17 点自动运行
  workflow_dispatch:      # 允许手动触发

permissions:
  contents: write
  actions: read

jobs:
  sync-fork:
    runs-on: ubuntu-latest
    steps:
      # 1️⃣ 检出你的 fork 仓库
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          persist-credentials: false
          fetch-depth: 0

      # 2️⃣ 安装必要工具
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl
          # 安装 GitHub CLI
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt-get update
          sudo apt-get install -y gh

      # 3️⃣ 配置 Git
      - name: Configure git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      # 4️⃣ 备份工作流文件
      - name: Backup workflow files
        run: |
          mkdir -p /tmp/backup
          # 只备份同步工作流本身
          if [ -f ".github/workflows/sync.yml" ]; then
            cp .github/workflows/sync.yml /tmp/backup/
            echo "Backed up sync workflow"
          else
            echo "No sync workflow found to backup"
          fi

      # 4.5️⃣ 删除所有可能导致问题的工作流文件
      - name: Remove problematic workflow files
        run: |
          # 删除所有可能触发构建的工作流文件
          rm -f .github/workflows/build.yml 2>/dev/null || true
          rm -f .github/workflows/android.yml 2>/dev/null || true
          rm -f .github/workflows/ci.yml 2>/dev/null || true
          rm -f .github/workflows/release.yml 2>/dev/null || true
          echo "Removed problematic workflow files"
          
          # 删除 Android 签名配置文件
          rm -f android/key.properties 2>/dev/null || true
          rm -f android/app/android_keystore.jks 2>/dev/null || true
          # 删除可能引用这些文件的 Gradle 配置
          sed -i '/android_keystore/d' android/app/build.gradle 2>/dev/null || true
          echo "Removed Android config files"

      # 5️⃣ 添加上游仓库并获取所有内容
      - name: Add upstream and fetch
        run: |
          git remote remove upstream 2>/dev/null || true
          git remote add upstream https://github.com/5VNetwork/vproxy.git
          git fetch upstream --tags --force --prune
          git fetch upstream --force --prune '+refs/heads/*:refs/remotes/upstream/*'

      # 6️⃣ 同步所有分支（保留工作流文件）
      - name: Sync branches with workflow preservation
        run: |
          # 获取默认分支名称
          default_branch=$(git remote show origin | grep 'HEAD branch' | cut -d' ' -f5 || echo "main")
          echo "Default branch: $default_branch"
          
          # 获取上游所有分支
          git show-ref | grep 'refs/remotes/upstream/' | while read hash ref; do
            branch_name=${ref#refs/remotes/upstream/}
            
            # 跳过 HEAD 引用
            if [ "$branch_name" = "HEAD" ]; then
              continue
            fi
            
            echo "Processing branch: $branch_name"
            
            # 创建或更新本地分支
            if git show-ref --verify --quiet refs/heads/$branch_name; then
              echo "Updating existing branch: $branch_name"
              git checkout $branch_name
              
              # 对于默认分支，使用合并而不是重置，以保留工作流文件
              if [ "$branch_name" = "$default_branch" ]; then
                echo "Merging upstream changes to default branch (preserving workflows)"
                # 关键修改：添加 --allow-unrelated-histories 选项
                git merge --no-commit --allow-unrelated-histories upstream/$branch_name
                
                # 恢复工作流文件
                if [ -f "/tmp/backup/sync.yml" ]; then
                  mkdir -p .github/workflows
                  cp /tmp/backup/sync.yml .github/workflows/
                  git add .github/workflows/sync.yml
                fi
                
                # 提交合并
                if ! git diff --cached --quiet; then
                  git commit -m "Merge upstream changes and preserve workflows"
                fi
              else
                # 对于非默认分支，使用硬重置
                git reset --hard upstream/$branch_name
              fi
            else
              echo "Creating new branch: $branch_name"
              git checkout -b $branch_name upstream/$branch_name
            fi
            
            # 推送到 origin - 使用认证信息
            echo "Pushing $branch_name to origin"
            git push https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git $branch_name --force
          done

      # 7️⃣ 同步所有标签（跳过包含工作流文件的标签）
      - name: Sync tags selectively
        run: |
          # 删除所有本地标签（避免冲突）
          git tag -l | xargs git tag -d 2>/dev/null || true
          # 获取上游所有标签
          git fetch upstream --tags --force
          
          # 获取所有标签
          git tag -l | while read tag; do
            # 检查标签是否包含工作流文件
            if git ls-tree -r $tag | grep -q ".github/workflows/"; then
              echo "Skipping tag $tag (contains workflow files)"
            else
              echo "Pushing tag $tag"
              git push https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git $tag --force || echo "Failed to push tag $tag"
            fi
          done

      # 8️⃣ 获取上游发布列表和本地发布列表，并检测需要同步的发布
      - name: Get release lists and detect changes
        id: get_releases
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 获取上游所有发布（按创建时间排序）
          echo "Getting upstream releases..."
          upstream_releases_json=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/5VNetwork/vproxy/releases?per_page=100")
          
          # 获取本地所有发布（按创建时间排序）
          echo "Getting local releases..."
          local_releases_json=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/releases?per_page=100")
          
          # 找出需要同步的新发布或需要更新的发布
          releases_to_sync=""
          
          # 处理每个上游发布
          echo "$upstream_releases_json" | jq -r '.[] | @base64' | while read -r release; do
            _jq() {
              echo "${release}" | base64 --decode | jq -r "${1}"
            }
            
            tag_name=$(_jq '.tag_name')
            prerelease=$(_jq '.prerelease')
            draft=$(_jq '.draft')
            assets_count=$(_jq '.assets | length')
            published_at=$(_jq '.published_at')
            body=$(echo "${release}" | base64 --decode | jq -r '.body')
            
            echo "Checking upstream release: $tag_name (prerelease: $prerelease, draft: $draft)"
            
            # 检查本地是否存在该发布
            local_release=$(echo "$local_releases_json" | jq --arg tag "$tag_name" '.[] | select(.tag_name == $tag)')
            
            if [ -z "$local_release" ]; then
              # 新发布，需要同步
              echo "New release to sync: $tag_name"
              echo "$tag_name:new" >> /tmp/releases_to_sync
            else
              # 已有发布，检查是否需要更新
              local_prerelease=$(echo "$local_release" | jq -r '.prerelease')
              local_draft=$(echo "$local_release" | jq -r '.draft')
              local_assets_count=$(echo "$local_release" | jq -r '.assets | length')
              local_published_at=$(echo "$local_release" | jq -r '.published_at')
              local_body=$(echo "$local_release" | jq -r '.body')
              
              echo "Local release: $tag_name (prerelease: $local_prerelease, draft: $local_draft)"
              
              # 检查发布状态是否有变更（从预发布变为正式发布，或从草稿变为发布）
              if [ "$prerelease" != "$local_prerelease" ]; then
                echo "Release prerelease status changed for $tag_name: upstream=$prerelease, local=$local_prerelease"
                echo "$tag_name:update_prerelease" >> /tmp/releases_to_sync
              elif [ "$draft" != "$local_draft" ]; then
                echo "Release draft status changed for $tag_name: upstream=$draft, local=$local_draft"
                echo "$tag_name:update_draft" >> /tmp/releases_to_sync
              # 检查资产文件数量是否有变更
              elif [ "$assets_count" != "$local_assets_count" ]; then
                echo "Release assets count changed for $tag_name: $assets_count vs $local_assets_count"
                echo "$tag_name:update_assets" >> /tmp/releases_to_sync
              # 检查发布时间是否有变更（可能是重新发布）
              elif [ "$published_at" != "$local_published_at" ]; then
                echo "Release publish time changed for $tag_name: $published_at vs $local_published_at"
                echo "$tag_name:update_all" >> /tmp/releases_to_sync
              # 检查发布内容是否有变更
              elif [ "$body" != "$local_body" ]; then
                echo "Release body changed for $tag_name"
                echo "$tag_name:update_body" >> /tmp/releases_to_sync
              fi
            fi
          done
          
          # 将结果设置为输出变量
          if [ -f /tmp/releases_to_sync ]; then
            releases_to_sync=$(cat /tmp/releases_to_sync | tr '\n' ' ')
            echo "Releases to sync: $releases_to_sync"
            echo "releases_to_sync=$releases_to_sync" >> $GITHUB_OUTPUT
          else
            echo "No releases to sync"
            echo "releases_to_sync=" >> $GITHUB_OUTPUT
          fi

      # 9️⃣ 下载需要同步的发布资源
      - name: Download release assets
        if: steps.get_releases.outputs.releases_to_sync != ''
        run: |
          mkdir -p releases
          releases_to_sync="${{ steps.get_releases.outputs.releases_to_sync }}"
          
          echo "Releases to process: $releases_to_sync"
          
          # 循环处理每个需要同步的发布
          for release_info in $releases_to_sync; do
            tag_name=$(echo "$release_info" | cut -d':' -f1)
            action=$(echo "$release_info" | cut -d':' -f2)
            echo "Processing release: $tag_name (action: $action)"
            
            # 获取发布详情
            release_info_json=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/5VNetwork/vproxy/releases/tags/$tag_name")
            
            # 检查是否有错误
            if echo "$release_info_json" | jq -e '.message' > /dev/null 2>&1; then
              echo "Error getting release $tag_name: $(echo "$release_info_json" | jq -r '.message')"
              continue
            fi
            
            release_id=$(echo "$release_info_json" | jq -r '.id')
            created_at=$(echo "$release_info_json" | jq -r '.created_at')
            echo "Release ID: $release_id, Created at: $created_at"
            
            # 为每个标签创建子目录
            mkdir -p "releases/$tag_name"
            
            # 保存发布信息到文件（包括创建时间）
            echo "$release_info_json" > "releases/$tag_name/release_info.json"
            
            # 下载每个资源
            assets=$(echo "$release_info_json" | jq -r '.assets | length')
            echo "Found $assets assets for $tag_name"
            
            if [ "$assets" -gt 0 ]; then
              for i in $(seq 0 $(($assets-1))); do
                asset_name=$(echo "$release_info_json" | jq -r ".assets[$i].name")
                download_url=$(echo "$release_info_json" | jq -r ".assets[$i].browser_download_url")
                
                echo "Downloading asset: $asset_name"
                curl -L -o "releases/$tag_name/$asset_name" "$download_url" || echo "Failed to download $asset_name"
              done
            else
              echo "No assets found for $tag_name"
            fi
            
            # 添加延迟以避免速率限制
            sleep 2
          done

      # 🔟 按照上游创建时间顺序创建或更新 GitHub Releases
      - name: Create or update GitHub Releases in order
        if: steps.get_releases.outputs.releases_to_sync != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          releases_to_sync="${{ steps.get_releases.outputs.releases_to_sync }}"
          
          # 首先，收集所有需要创建的发布的信息（标签名、创建时间和操作类型）
          declare -A release_dates
          declare -A release_actions
          for release_info in $releases_to_sync; do
            tag_name=$(echo "$release_info" | cut -d':' -f1)
            action=$(echo "$release_info" | cut -d':' -f2)
            tag_dir="releases/$tag_name"
            release_info_file="$tag_dir/release_info.json"
            
            if [ -f "$release_info_file" ]; then
              created_at=$(jq -r '.created_at' "$release_info_file")
              # 将日期转换为时间戳以便排序
              timestamp=$(date -d "$created_at" +%s)
              release_dates[$tag_name]=$timestamp
              release_actions[$tag_name]=$action
            else
              # 如果没有找到发布信息文件，使用当前时间戳
              release_dates[$tag_name]=$(date +%s)
              release_actions[$tag_name]=$action
            fi
          done

          # 按照时间戳排序标签名
          # 由于 Bash 关联数组不能直接排序，我们将标签名和时间戳放入数组然后排序
          # 创建一个数组，元素格式为：时间戳:标签名:操作类型
          for tag_name in "${!release_dates[@]}"; do
            printf "%d:%s:%s\n" "${release_dates[$tag_name]}" "$tag_name" "${release_actions[$tag_name]}"
          done | sort -n | while IFS=: read -r timestamp tag_name action; do
            # 现在按照排序后的顺序处理每个标签
            tag_dir="releases/$tag_name"
            
            if [ -d "$tag_dir" ]; then
              echo "Processing release: $tag_name (action: $action)"
              
              # 读取发布信息
              release_info_file="$tag_dir/release_info.json"
              if [ -f "$release_info_file" ]; then
                release_name=$(jq -r '.name' "$release_info_file")
                release_notes=$(jq -r '.body' "$release_info_file")
                prerelease=$(jq -r '.prerelease' "$release_info_file")
                draft=$(jq -r '.draft' "$release_info_file")
                
                echo "Upstream release: $tag_name (prerelease: $prerelease, draft: $draft)"
                
                # 收集所有资产文件（排除 release_info.json）
                asset_files=()
                for file in "$tag_dir"/*; do
                  if [[ "$file" != *"release_info.json" ]]; then
                    asset_files+=("$file")
                  fi
                done
                
                if [ "$action" = "new" ]; then
                  # 创建新发布
                  echo "Creating new release: $tag_name"
                  
                  # 设置发布参数
                  prerelease_flag=""
                  draft_flag=""
                  if [ "$prerelease" = "true" ]; then
                    prerelease_flag="--prerelease"
                  fi
                  if [ "$draft" = "true" ]; then
                    draft_flag="--draft"
                  fi
                  
                  if [ -n "$release_name" ] && [ "$release_name" != "null" ]; then
                    gh release create --repo ${{ github.repository }} "$tag_name" \
                      --title "$release_name" \
                      --notes "$release_notes" \
                      $prerelease_flag \
                      $draft_flag \
                      --target main || echo "Release $tag_name may already exist"
                  else
                    gh release create --repo ${{ github.repository }} "$tag_name" \
                      --notes "$release_notes" \
                      $prerelease_flag \
                      $draft_flag \
                      --target main || echo "Release $tag_name may already exist"
                  fi
                  
                  # 上传资产文件
                  for asset_file in "${asset_files[@]}"; do
                    echo "Uploading asset: $asset_file"
                    gh release upload --repo ${{ github.repository }} "$tag_name" "$asset_file" || echo "Failed to upload $asset_file"
                    sleep 1  # 避免速率限制
                  done
                else
                  # 更新已有发布
                  echo "Updating existing release: $tag_name (action: $action)"
                  
                  # 根据不同的操作类型执行不同的更新
                  case $action in
                    "update_prerelease")
                      echo "Updating prerelease status for $tag_name to: $prerelease"
                      # 明确设置预发布状态
                      if [ "$prerelease" = "true" ]; then
                        gh release edit --repo ${{ github.repository }} "$tag_name" \
                          --prerelease || echo "Failed to set prerelease for $tag_name"
                      else
                        gh release edit --repo ${{ github.repository }} "$tag_name" \
                          --prerelease=false || echo "Failed to unset prerelease for $tag_name"
                      fi
                      ;;
                    "update_draft")
                      echo "Updating draft status for $tag_name to: $draft"
                      # 明确设置草稿状态
                      if [ "$draft" = "true" ]; then
                        gh release edit --repo ${{ github.repository }} "$tag_name" \
                          --draft || echo "Failed to set draft for $tag_name"
                      else
                        gh release edit --repo ${{ github.repository }} "$tag_name" \
                          --draft=false || echo "Failed to unset draft for $tag_name"
                      fi
                      ;;
                    "update_body")
                      echo "Updating release body for $tag_name"
                      # 只更新发布说明
                      gh release edit --repo ${{ github.repository }} "$tag_name" \
                        --notes "$release_notes" || echo "Failed to update release body for $tag_name"
                      ;;
                    "update_assets")
                      echo "Updating release assets for $tag_name"
                      # 获取当前发布的资产文件列表
                      existing_assets=$(gh release view --repo ${{ github.repository }} "$tag_name" --json assets --jq '.assets[].name' 2>/dev/null || echo "")
                      
                      # 删除旧的资产文件（如果存在）
                      if [ -n "$existing_assets" ]; then
                        echo "Deleting existing assets for $tag_name"
                        for asset in $existing_assets; do
                          gh release delete-asset --repo ${{ github.repository }} "$tag_name" "$asset" || echo "Failed to delete asset $asset"
                          sleep 1  # 避免速率限制
                        done
                      fi
                      
                      # 上传新的资产文件
                      for asset_file in "${asset_files[@]}"; do
                        echo "Uploading asset: $asset_file"
                        gh release upload --repo ${{ github.repository }} "$tag_name" "$asset_file" || echo "Failed to upload $asset_file"
                        sleep 1  # 避免速率限制
                      done
                      ;;
                    "update_all")
                      echo "Updating all release properties for $tag_name"
                      # 获取当前发布的资产文件列表
                      existing_assets=$(gh release view --repo ${{ github.repository }} "$tag_name" --json assets --jq '.assets[].name' 2>/dev/null || echo "")
                      
                      # 删除旧的资产文件（如果存在）
                      if [ -n "$existing_assets" ]; then
                        echo "Deleting existing assets for $tag_name"
                        for asset in $existing_assets; do
                          gh release delete-asset --repo ${{ github.repository }} "$tag_name" "$asset" || echo "Failed to delete asset $asset"
                          sleep 1  # 避免速率限制
                        done
                      fi
                      
                      # 更新发布信息
                      gh release edit --repo ${{ github.repository }} "$tag_name" \
                        --title "$release_name" \
                        --notes "$release_notes" || echo "Failed to update release info for $tag_name"
                      
                      # 明确设置预发布状态
                      if [ "$prerelease" = "true" ]; then
                        gh release edit --repo ${{ github.repository }} "$tag_name" \
                          --prerelease || echo "Failed to set prerelease for $tag_name"
                      else
                        gh release edit --repo ${{ github.repository }} "$tag_name" \
                          --prerelease=false || echo "Failed to unset prerelease for $tag_name"
                      fi
                      
                      # 明确设置草稿状态
                      if [ "$draft" = "true" ]; then
                        gh release edit --repo ${{ github.repository }} "$tag_name" \
                          --draft || echo "Failed to set draft for $tag_name"
                      else
                        gh release edit --repo ${{ github.repository }} "$tag_name" \
                          --draft=false || echo "Failed to unset draft for $tag_name"
                      fi
                      
                      # 上传新的资产文件
                      for asset_file in "${asset_files[@]}"; do
                        echo "Uploading asset: $asset_file"
                        gh release upload --repo ${{ github.repository }} "$tag_name" "$asset_file" || echo "Failed to upload $asset_file"
                        sleep 1  # 避免速率限制
                      done
                      ;;
                  esac
                fi
                
                echo "Processed release: $tag_name"
              else
                echo "No release info found for $tag_name"
              fi
            else
              echo "No assets found for $tag_name"
            fi
            
            # 添加延迟以避免速率限制
            sleep 5
          done

      # 清理下载的资源
      - name: Clean up downloaded assets
        run: |
          rm -rf releases
          echo "Cleaned up downloaded assets"

      # 发送完成通知
      - name: Notify on completion
        run: |
          releases_to_sync="${{ steps.get_releases.outputs.releases_to_sync }}"
          if [ -n "$releases_to_sync" ]; then
            echo "Sync completed at $(date)"
            echo "Releases processed: $releases_to_sync"
          else
            echo "Sync completed at $(date)"
            echo "No releases to sync"
          fi
          echo "Repository: https://github.com/${{ github.repository }}"
